#include "FFT.H"

char Lcd_Disp_String1[21]; // 显示数组
char Lcd_Disp_String2[21];
char Lcd_Disp_String3[21]; // 显示数组
char Lcd_Disp_String4[21];
unsigned char temp1[1] = {2};
float am2 = 0;
float f1, f2, in1, in2, in3;
int temp, m, time = 0;
uint16_t am1 = 0;
int mode = 0;
int fm = 0;
float mf = 0;
float mf2 = 0;
int idx;
float32_t FFT_Outputdata[FFT_Len];          // FFT结果输出
float32_t FFT_Inputbuf[FFT_Len];            // FFT数据输入
float32_t FFT_Mag_Outputdata[Half_FFT_Len]; // 计算复数的模
uint16_t ADC_Value[1024];
float32_t ADC_Value_V[1024];
float32_t max1 = 0, max2 = 0, max3 = 0;

// float beisaier[50] = {0.5751,   0.6544,  0.7425, 0.8419, 0.9561, 1.0901, 1.2514,                       
//                       1.4517,   1.7104,  2.0622, 2.5759, 3.4110, 5.0376, 9.7205,
//                       207.4366, 10.2740, 4.8636, 3.1001, 2.2142, 1.6737, 1.3038,
//                       1.0303,   0.8162,  0.6409, 0.4920, 0.3614, 0.2437,
//                       0.1348, 0.0318,   0.0678,  0.1663, 0.2657, 0.3682,
//                       0.4762, 0.5925, 0.7208, 0.8663,  1.0362, 1.2415, 1.5004, 1.8445
//                      };
/////2/1
// float beisaier2[450] = {
//     0.26111, 0.26397, 0.26683, 0.26969, 0.27257, 0.27546, 0.27835, 0.28125,
//     0.28416, 0.28708, 0.29001, 0.29294, 0.29589, 0.29884, 0.30181, 0.30478,
//     0.30776, 0.31075, 0.31376, 0.31677, 0.31979, 0.32283, 0.32587, 0.32892,
//     0.33199, 0.33506, 0.33815, 0.34125, 0.34436, 0.34748, 0.35061, 0.35375,
//     0.35691, 0.36008, 0.36326, 0.36645, 0.36966, 0.37288, 0.37611, 0.37935,
//     0.38261, 0.38588, 0.38917, 0.39247, 0.39578, 0.39911, 0.40245, 0.40581,
//     0.40918, 0.41257, 0.41598, 0.41939, 0.42283, 0.42628, 0.42975, 0.43323,
//     0.43673, 0.44025, 0.44378, 0.44733, 0.4509,  0.45449, 0.4581,  0.46172,
//     0.46536, 0.46903, 0.47271, 0.47641, 0.48013, 0.48387, 0.48764, 0.49142,
//     0.49522, 0.49905, 0.5029,  0.5067,  0.51066, 0.51457, 0.51851, 0.52247,
//     0.52646, 0.53047, 0.5345,  0.53856, 0.54264, 0.54675, 0.55089, 0.55505,
//     0.55924, 0.56346, 0.5677,  0.57198, 0.57628, 0.58061, 0.58497, 0.58936,
//     0.59379, 0.59824, 0.60272, 0.60724, 0.61179, 0.61637, 0.62099, 0.62564,
//     0.63033, 0.63505, 0.6398,  0.6446,  0.64943, 0.6543,  0.65921, 0.66416,
//     0.66915, 0.67417, 0.67925, 0.68436, 0.68951, 0.69471, 0.69996, 0.70525,
//     0.71058, 0.71597, 0.7214,  0.72688, 0.73241, 0.73799, 0.74362, 0.74931,
//     0.75505, 0.76084, 0.76669, 0.7726,  0.77856, 0.78458, 0.79067, 0.79681,
//     0.80302, 0.8093,  0.81563, 0.82204, 0.82851, 0.83506, 0.84167, 0.84836,
//     0.85512, 0.86195, 0.86887, 0.87586, 0.88294, 0.89009, 0.89733, 0.90466,
//     0.91208, 0.91958, 0.92718, 0.93488, 0.94267, 0.95055, 0.95855, 0.96664,
//     0.97484, 0.98315, 0.99157, 1.0001,  1.0088,  1.0175,  1.0264,  1.0355,
//     1.0446,  1.0539,  1.0633,  1.0729,  1.0826,  1.0924,  1.1024,  1.1126,
//     1.1229,  1.1334,  1.1441,  1.1549,  1.1659,  1.1771,  1.1885,  1.2001,
//     1.2119,  1.2238,  1.236,   1.2485,  1.2611,  1.274,   1.2871,  1.3005,
//     1.3142,  1.3281,  1.3422,  1.3567,  1.3715,  1.3865,  1.4019,  1.4176,
//     1.4336,  1.45,    1.4668,  1.4839,  1.5015,  1.5194,  1.5377,  1.5565,
//     1.5758,  1.5955,  1.6157,  1.6365,  1.6577,  1.6795,  1.702,   1.725,
//     1.7486,  1.7729,  1.7979,  1.8237,  1.8502,  1.8775,  1.9056,  1.9346,
//     1.9645,  1.9954,  2.0273,  2.0603,  2.0944,  2.1298,  2.1663,  2.2043,
//     2.2436,  2.2844,  2.3268,  2.3709,  2.4168,  2.4646,  2.5145,  2.5665,
//     2.6208,  2.6777,  2.7372,  2.7996,  2.865,   2.9339,  3.0063,  3.0826,
//     3.1631,  3.2483,  3.3385,  3.4341,  3.5358,  3.6441,  3.7597,  3.8834,
//     4.016,   4.1586,  4.3124,  4.4788,  4.6593,  4.856,   5.0711,  5.3073,
//     5.5679,  5.857,   6.1795,  6.5417,  6.9514,  7.4186,  7.9565,  8.5824,
//     9.32,    10.202,  11.277,  12.613,  14.322,  16.584,  19.721,  24.36,
//     31.925,  46.457,  85.815,  586.57,  120.18,  54.267,  34.946,  25.714,
//     20.305,  16.75,   14.236,  12.364,  10.915,  9.7607,  8.8191,  8.0362,
//     7.3751,  6.8092,  6.3194,  5.8911,  5.5135,  5.1779,  4.8778,  4.6077,
//     4.3633,  4.1411,  3.9381,  3.7519,  3.5806,  3.4223,  3.2757,  3.1394,
//     3.0124,  2.8938,  2.7826,  2.6784,  2.5803,  2.4878,  2.4005,  2.318,
//     2.2398,  2.1655,  2.095,   2.0279,  1.9639,  1.9029,  1.8446,  1.7888,
//     1.7354,  1.6842,  1.635,   1.5879,  1.5425,  1.4988,  1.4567,  1.4162,
//     1.3771,  1.3393,  1.3028,  1.2675,  1.2333,  1.2002,  1.1682,  1.1371,
//     1.1069,  1.0776,  1.0491,  1.0214,  0.99453, 0.96833, 0.94282, 0.91797,
//     0.89375, 0.87012, 0.84707, 0.82457, 0.80259, 0.78112, 0.76013, 0.7396,
//     0.71951, 0.69985, 0.6806,  0.66174, 0.64326, 0.62515, 0.60738, 0.58994,
//     0.57283, 0.55603, 0.53953, 0.52332, 0.50738, 0.49172, 0.47631, 0.46115,
//     0.44623, 0.43154, 0.41707, 0.40282, 0.38878, 0.37494, 0.36129, 0.34783,
//     0.33455, 0.32144, 0.3085,  0.29572, 0.28311, 0.27064, 0.25832, 0.24614,
//     0.2341,  0.22219, 0.2104,  0.19875, 0.1872,  0.17578, 0.16446, 0.15325,
//     0.14215};
int bas = 0;
int bas1 = 0;
// float beisaier[450] = {
//     0.1502,   0.1538,    0.1575,   0.1613,   0.1651,   0.1691,   0.1731,
//     0.1771,   0.1813,    0.1855,   0.1898,   0.1941,   0.1986,   0.2031,
//     0.2078,   0.2125,    0.2173,   0.2222,   0.2272,   0.2323,   0.2374,
//     0.2427,   0.2481,    0.2536,   0.2592,   0.2649,   0.2707,   0.2766,
//     0.2827,   0.2889,    0.2952,   0.3016,   0.3081,   0.3148,   0.3217,
//     0.3286,   0.3358,    0.3430,   0.3505,   0.3581,   0.3658,   0.3737,
//     0.3818,   0.3901,    0.3985,   0.4072,   0.4160,   0.4251,   0.4343,
//     0.4438,   0.4534,    0.4634,   0.4735,   0.4839,   0.4946,   0.5055,
//     0.5166,   0.5281,    0.5399,   0.5519,   0.5643,   0.5770,   0.5900,
//     0.6033,   0.6171,    0.6312,   0.6457,   0.6606,   0.6759,   0.6917,
//     0.7079,   0.7246,    0.7418,   0.7596,   0.7778,   0.7967,   0.8161,
//     0.8362,   0.8569,    0.8783,   0.9005,   0.9233,   0.9470,   0.9715,
//     0.9969,   1.0233,    1.0506,   1.0789,   1.1083,   1.1389,   1.1707,
//     1.2038,   1.2383,    1.2742,   1.3117,   1.3509,   1.3918,   1.4347,
//     1.4795,   1.5266,    1.5759,   1.6278,   1.6824,   1.7399,   1.8006,
//     1.8647,   1.9325,    2.0044,   2.0808,   2.1620,   2.2485,   2.3410,
//     2.4399,   2.5461,    2.6602,   2.7834,   2.9166,   3.0612,   3.2186,
//     3.3907,   3.5797,    3.7880,   4.0189,   4.2762,   4.5648,   4.8906,
//     5.2615,   5.6873,    6.1815,   6.7617,   7.4526,   8.2892,   9.3231,
//     10.6334,  12.3480,   14.6879,  18.0720,  23.3995,  33.0189,  55.6152,
//     171.8638, 161.2060, 55.2879, 33.5171, 24.1251, 18.8911, 15.5544,
//     13.2416, 11.5441,  10.2452, 9.2192,  8.3883,  7.7017,  7.1247,
//     6.6331,  6.2093,   5.8400,  5.5154,  5.2279,  4.9714,  4.7412,
//     4.5334,  4.3449,   4.1732,  4.0160,  3.8716,  3.7386,  3.6155,
//     3.5014,  3.3953,   3.2963,  3.2039,  3.1172,  3.0359,  2.9594,
//     2.8874,  2.8194,   2.7551,  2.6942,  2.6364,  2.5816,  2.5294,
//     2.4798,  2.4325,   2.3873,  2.3441,  2.3028,  2.2633,  2.2255,
//     2.1891,  2.1543,   2.1208,  2.0885,  2.0575,  2.0277,  1.9989,
//     1.9711,  1.9443,   1.9184,  1.8934,  1.8692,  1.8458,  1.8231,
//     1.8012,  1.7799,   1.7593,  1.7392,  1.7198,  1.7009,  1.6826,
//     1.6647,  1.6474,   1.6305,  1.6141,  1.5981,  1.5825,  1.5673,
//     1.5525,  1.5380,   1.5239,  1.5101,  1.4967,  1.4836,  1.4707,
//     1.4582,  1.4459,   1.4339,  1.4222,  1.4107,  1.3994,  1.3884,
//     1.3776,  1.3671,   1.3567,  1.3465,  1.3366,  1.3268,  1.3172,
//     1.3077,  1.2985,   1.2894,  1.2805,  1.2717,  1.2631,  1.2546,
//     1.2463,  1.2380,   1.2300,  1.2220,  1.2142,  1.2065,  1.1989,
//     1.1915,  1.1841,   1.1768,  1.1697,  1.1626,  1.1557,  1.1488,
//     1.1421,  1.1354,   1.1288,  1.1223,  1.1158,  1.1095,  1.1032,
//     1.0970,  1.0909,   1.0848,  1.0788,  1.0729,  1.0670,  1.0612,
//     1.0555,  1.0498,   1.0442,  1.0386,  1.0330,  1.0276,  1.0221,
//     1.0168,  1.0114,   1.0061,  1.0009,  0.9957,  0.9905,  0.9854,
//     0.9803,  0.9752,   0.9702,  0.9652,  0.9603,  0.9553,  0.9504,
//     0.9456,  0.9407,   0.9359,  0.9311,  0.9263,  0.9216,  0.9169,
//     0.9121,  0.9074,   0.9028,  0.8981,  0.8935,  0.8888,  0.8842,
//     0.8796,  0.8750,   0.8704,  0.8658,  0.8612,  0.8566,  0.8521,
//     0.8475,  0.8429,   0.8384,  0.8338,  0.8292,  0.8247,  0.8201,
//     0.8155,  0.8109,   0.8063,  0.8017,  0.7971,  0.7925,  0.7879,
//     0.7832,  0.7785,   0.7738,  0.7691,  0.7644,  0.7597,  0.7549,
//     0.7501,  0.7453,   0.7405,  0.7356,  0.7307,  0.7258,  0.7208,
//     0.7158,  0.7108,   0.7057,  0.7006,  0.6954,  0.6902,  0.6849,
//     0.6796,  0.6743,   0.6689,  0.6634,  0.6579,  0.6523,  0.6466,
//     0.6409,  0.6351,   0.6293,  0.6233,  0.6173,  0.6112,  0.6050,
//     0.5988,  0.5924,   0.5860,  0.5794,  0.5727,  0.5660,  0.5591,
//     0.5521,  0.5449,   0.5377,  0.5303,  0.5227,  0.5150,  0.5072,
//     0.4992,  0.4910,   0.4827,  0.4742,  0.4654,  0.4565,  0.4474,
//     0.4380,  0.4285,   0.4186,  0.4086,  0.3982,  0.3876,  0.3767,
//     0.3654,  0.3539,   0.3420,  0.3297,  0.3171,  0.3040,  0.2905,
//     0.2766,  0.2622};

/// 2/0
/////这条编译链专用的串口重构函数
// int _write(int file, char *ptr, int len) {
//   HAL_UART_Transmit(&huart3, (uint8_t *)ptr, len, HAL_MAX_DELAY);
//   return len;
// }


// AM的FFT频谱是两个 FM是一堆尖峰 CW是只有一个尖峰

void FFT_test(float32_t FFT_Inputbuf[]) {
  uint16_t i;

  ADC_FFT(ADC_Value);
  arm_rfft_fast_instance_f32 S;
  uint16_t max_index1 = 0, max_index2 = 0, max_index3 = 0, max_index4 = 0,
           max_index5 = 0;

  float32_t max_mag1 = 0.0f, max_mag2 = 0.0f, max_mag3 = 0.0f, max_mag4 = 0.0f;
  arm_rfft_fast_init_f32(&S, FFT_Len);

  arm_rfft_fast_f32(&S, FFT_Inputbuf, FFT_Outputdata, 0);
  arm_cmplx_mag_f32(FFT_Outputdata, FFT_Mag_Outputdata, FFT_Len);

  // float32_t fs = 400000.0f;  // 采样频率 400 kHz
  // float32_t delta_f = fs / FFT_Len;  // 频率分辨率

  // 第一步 找到2MHZ的点 大约在第341个点
  for (i = 335; i < 346; i++) {
    if (FFT_Mag_Outputdata[i] > max_mag1) {
      max_mag1 = FFT_Mag_Outputdata[i];
      max_index1 = i;
    }
  }

  // 计算平方和
  max_mag1 = sqrt((FFT_Mag_Outputdata[max_index1 - 1] / 512) *
                      (FFT_Mag_Outputdata[max_index1 - 1] / 512) +
                  (FFT_Mag_Outputdata[max_index1] / 512) *
                      (FFT_Mag_Outputdata[max_index1] / 512) +
                  (FFT_Mag_Outputdata[max_index1 + 1] / 512) *
                      (FFT_Mag_Outputdata[max_index1 + 1] / 512));

  // 从中间向左边搜索  找到调制频率的频谱 1，2，3，4，5KHZ
  for (i = 335; i > 20; i--) {
    if (FFT_Mag_Outputdata[i] > 8) {
      if (FFT_Mag_Outputdata[i] >
              FFT_Mag_Outputdata[i - 1] && // 峰值判定：比左侧大
          FFT_Mag_Outputdata[i] > FFT_Mag_Outputdata[i + 1]) {
        max_index2 = i;
        break;
      }
    }
  }

  max_mag2 = sqrt((FFT_Mag_Outputdata[max_index2 - 1] / 512) *
                      (FFT_Mag_Outputdata[max_index2 - 1] / 512) +
                  (FFT_Mag_Outputdata[max_index2] / 512) *
                      (FFT_Mag_Outputdata[max_index2] / 512) +
                  (FFT_Mag_Outputdata[max_index2 + 1] / 512) *
                      (FFT_Mag_Outputdata[max_index2 + 1] / 512));

  for (i = max_index2 - 5; i > 20; i--) {
    if (FFT_Mag_Outputdata[i] > 8) {
      if (FFT_Mag_Outputdata[i] >
              FFT_Mag_Outputdata[i - 1] && // 峰值判定：比左侧大
          FFT_Mag_Outputdata[i] > FFT_Mag_Outputdata[i + 1]) {
        max_index5 = i;
        break;
      }
    }
  }
  // 计算平方和

  max_mag4 = sqrt((FFT_Mag_Outputdata[max_index5 - 1] / 512) *
                      (FFT_Mag_Outputdata[max_index5 - 1] / 512) +
                  (FFT_Mag_Outputdata[max_index5] / 512) *
                      (FFT_Mag_Outputdata[max_index5] / 512) +
                  (FFT_Mag_Outputdata[max_index5 + 1] / 512) *
                      (FFT_Mag_Outputdata[max_index5 + 1] / 512));

  // 从中间向右边搜索  找到调制频率的频谱 1，2，3，4，5KHZ
  for (i = 355; i < Half_FFT_Len - 10; i++) {
    if (FFT_Mag_Outputdata[i] > 8) {
      if (FFT_Mag_Outputdata[i] >
              FFT_Mag_Outputdata[i - 1] && // 峰值判定：比左侧大
          FFT_Mag_Outputdata[i] > FFT_Mag_Outputdata[i + 1]) {
        max_index3 = i;
        break;
      }
    }
  }

  // 计算平方和
  max_mag3 = sqrt((FFT_Mag_Outputdata[max_index3 - 1] / 512.0f) *
                 (FFT_Mag_Outputdata[max_index3 - 1] / 512.0f) +
             (FFT_Mag_Outputdata[max_index3] / 512.0f) *
                 (FFT_Mag_Outputdata[max_index3] / 512.0f) +
             (FFT_Mag_Outputdata[max_index3 + 1] / 512.0f) *
                 (FFT_Mag_Outputdata[max_index3 + 1] / 512.0f));

  /// 对谱线进行判断  要求不但模值要够 还要避免频谱泄露的影响
  for (i = 330; i > 30; i--) {
    if (FFT_Mag_Outputdata[i] > 8) {
      if (FFT_Mag_Outputdata[i] >
              FFT_Mag_Outputdata[i - 1] && // 峰值判定：比左侧大
          FFT_Mag_Outputdata[i] >
              FFT_Mag_Outputdata[i + 1]) { // 峰值判定：比右侧大
        mode++;
      }
    }
  }

  for (i = 355; i < Half_FFT_Len - 10; i++) {
    if (FFT_Mag_Outputdata[i] > 8) {
      if (FFT_Mag_Outputdata[i] >
              FFT_Mag_Outputdata[i - 1] && // 峰值判定：比左侧大
          FFT_Mag_Outputdata[i] >
              FFT_Mag_Outputdata[i + 1]) { // 峰值判定：比右侧大
        mode++;
      }
    }
  }

  mode++;
  am2 = (max_mag3 + max_mag2) / max_mag1;
  am1 = (int)(am2 * 100.0f + 0.5f);

  for (m = 330; m > 220; m--) {
    if (FFT_Mag_Outputdata[m] > 10) {
      max_index4 = m; // 记录当前索引
      break;          // 找到第一个大于10的元素后退出循环
    }
  }
  if (max_index1 > max_index2) {
    temp = max_index1;
    max_index1 = max_index2;
    max_index2 = temp;
  }
  if (max_index1 > max_index3) {
    temp = max_index1;
    max_index1 = max_index3;
    max_index3 = temp;
  }
  if (max_index2 > max_index3) {
    temp = max_index2;
    max_index2 = max_index3;
    max_index3 = temp;
  }

  // 画出频谱
    //  for (i = 100;i < 440; i++)
    //      {
    //        printf("add s0.id,0,%d\xff\xff\xff",(int) FFT_Mag_Outputdata[i]);
    //      }

  // CW波的情况
  if (mode == 1) {
    // printf("page0.t0.txt=\"CW\"\xff\xff\xff");
    // printf("page0.n0.val=0\xff\xff\xff");
    // printf("page0.t2.txt=\" \"\xff\xff\xff");
    // printf("page0.t3.txt=\" \"\xff\xff\xff");
    mode = 0;
  }
  // AM波的情况
  if (mode == 3) {
    // printf("page0.t0.txt=\"AM\"\xff\xff\xff");
    // printf("page0.n0.val=%d\xff\xff\xff", am1);
    // printf("t2.txt=\"ma\"\xff\xff\xff");
    mode = 0;
  }

  // FM波的情况
  // if (mode > 4) {
  //   printf("page0.t0.txt=\"FM\"\xff\xff\xff");
  //   printf("page0.t2.txt=\"F\"\xff\xff\xff");
  //   printf("page0.t3.txt=\"fm\"\xff\xff\xff");
  //   m = abs(max_index4 - 341);
  //   f1 = m * 0.0585 + 0.5f;
  //   printf("page0.n0.val=%d\xff\xff\xff", (int)f1);

  //   mf = (max_mag4 / max_mag2);
  //   mf2 = (max_mag4 / max_mag1);

  //   int closestIdx1 = -1, closestIdx2 = -1, closestIdx3 = -1, closestIdx4 = -1;
  //   float minDiff1 = 1, minDiff2 = 1, minDiff3 = 1,
  //         minDiff4 = 1; // 用来存储最接近的两个差值

  //   // 查找最接近 mf 的两个值
  //   for (i = 0; i < 283; i++) {
  //     float diffMf = fabs(mf - beisaier2[i]); // 计算 mf 和当前值的差值
  //     // 如果当前差值比最小差值小，则更新第一个最接近索引，并把之前的最接近值移到第二接近
  //     if (diffMf < minDiff1) {
  //       minDiff1 = diffMf; // 更新最接近的差值
  //       closestIdx1 = i;   // 更新最接近的索引
  //     }
  //   }

  //   for (i =283; i < 401; i++) {
  //     float diffMf2 = fabs(mf - beisaier2[i]); // 计算 mf 和当前值的差值
  //     // 如果当前差值比最小差值小，则更新第一个最接近索引，并把之前的最接近值移到第二接近
  //     if (diffMf2 < minDiff2) {
  //       minDiff2 = diffMf2; // 更新最接近的差值
  //       closestIdx2 = i;    // 更新最接近的索引
  //     }
  //   }

  //   for (i = 0; i < 140; i++) {
  //     float diffMf3 = fabs(mf2 - beisaier[i]); // 计算 mf 和当前值的差值
  //     // 如果当前差值比最小差值小，则更新第一个最接近索引，并把之前的最接近值移到第二接近
  //     if (diffMf3 < minDiff3) {
  //       minDiff3 = diffMf3; // 更新最接近的差值
  //       closestIdx3 = i;    // 更新最接近的索引
  //     }
  //   }
  //   for (i = 140; i < 401; i++) {
  //     float diffMf4 = fabs(mf2 - beisaier[i]); // 计算 mf 和当前值的差值
  //     // 如果当前差值比最小差值小，则更新第一个最接近索引，并把之前的最接近值移到第二接近
  //     if (diffMf4 < minDiff4) {
  //       minDiff4 = diffMf4; // 更新最接近的差值
  //       closestIdx4 = i;    // 更新最接近的索引
  //     }
  //   }
  //   int a1, a2, b1, b2;
      
  //   a1 = fabs(closestIdx1 - closestIdx3);
  //   a2 = fabs(closestIdx1 - closestIdx4);
  //   b1 = fabs(closestIdx2 - closestIdx3);
  //   b2 = fabs(closestIdx2 - closestIdx4);
  //   int min_val = fmin(fmin(a1, a2), fmin(b1, b2));
  //   if (min_val == a1) {
  //     // bas=(closestIdx1+closestIdx3)/2;
  //     bas = closestIdx1;
  //   }

  //   if (min_val == a2) {
  //     ///  bas=(closestIdx1+closestIdx4)/2;
  //     bas = closestIdx1;
  //   }
  //   if (min_val == b1) {
  //     //   bas=(closestIdx2+closestIdx3)/2;
  //     bas = closestIdx2;
  //   }
  //   if (min_val == b2) {
  //     //  bas=(closestIdx2+closestIdx4)/2;
  //     bas = closestIdx2;
  //   }
  //   fm = (1 + bas * 0.01) * 10;

  //   printf("page0.x1.val=%d\xff\xff\xff", fm);

  //   mode = 0;
  // }
}

void ADC_FFT(uint16_t ADC_Value[1024]) {
  uint16_t i = 0;
  // ADC转换值转换为浮点数（电压值）
  for (i = 0; i < 1024; i++) {
    ADC_Value_V[i] = ((float32_t)ADC_Value[i] * 3.30f) / 1024.0f;
  }
}
